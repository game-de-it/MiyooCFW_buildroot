#!/bin/busybox sh

BOOTLOGO="/mnt/boot-logo"
export HOME=/mnt
export SDL_NOMOUSE=1
START="${HOME}/autoexec.sh"

BOOTDIR=/boot # we expect /dev/mmcblk0p1 has been mounted here read only, from inittab
LOGS=/dev/null

# check if it's first boot and turn on messages if yes
if ((test -r "${BOOTDIR}/firstboot") || (test -r "${HOME}/firstboot.completed")); then
	DEBUG_MSG="yes"
	LOGS=$(mktemp)
fi

export LOGS # so that subshells can use this as well

if test "x${DEBUG_MSG}" == "xyes"; then
	echo -e "\e[0m"    # normal foreground color
	export DEBUG_MSG   # set it globally for further programs
else
	echo -e "\e[30m"   # black foreground color
fi

# load kernel modules

# load usb gadget
mount -t configfs none /sys/kernel/config >> "${LOGS}" 2>&1
gadget-ms /dev/mmcblk0p1 /dev/mmcblk0p4 >> "${LOGS}" 2>&1


# Load the expected one screen driver from here with modprobe
## automatically from rootfs/lib/modules/VERSION
# The uEnv.txt is autogenerated by u-boot from HW which outputs
## environmental variables needed for ID of screen type
video=`cat ${BOOTDIR}/uEnv.txt |grep -a "CONSOLE_VIDEO" | cut -d "=" -f 2 | cut -d "." -f 1`
params=`cat ${BOOTDIR}/uEnv.txt |grep -a "CONSOLE_PARAMETERS" | cut -d "=" -f 2-`

BACKLIGHT=$(cat ${HOME}/.backlight.conf)

# TVout scripting backend
tvout=`cat ${HOME}/tvout`
if ((test -r "${HOME}/tvout")); then
	echo 0 > /sys/class/backlight/backlight/brightness
	echo 0 > /sys/class/vtconsole/vtcon1/bind
	if test $BACKLIGHT -ne 0; then
		cp ${HOME}/.backlight.conf ${HOME}/.backlight.bak
	fi
	echo 0 > ${HOME}/.backlight.conf
	modprobe -r $video
	#TVMODE options.cfg setting
	export tvmode=$(grep -o TVMODE=[0-1] "${HOME}/options.cfg" | tr '[:upper:]' '[:lower:]')
	modprobe miyoo-tvout $tvmode
	echo 1 > /sys/class/vtconsole/vtcon1/bind
	modprobe -r $video
else
	if ((test -r "${HOME}/.backlight.bak")); then
		mv ${HOME}/.backlight.bak ${HOME}/.backlight.conf
	fi
	# MODULES_CUSTOM scripting
	if (!(test -r "${BOOTDIR}/modules.custom.sh") || !(grep -q MODULES_CUSTOM\=\1 "${HOME}/options.cfg")); then
		# Load video module read from uEnv.txt & defined by variant in console.cfg
		#FLIP & INVERT options.cfg setting
		export flip=$(grep -o FLIP=[0-1] "${HOME}/options.cfg" | tr '[:upper:]' '[:lower:]')
		export invert=$(grep -o INVERT=[0-1] "${HOME}/options.cfg" | tr '[:upper:]' '[:lower:]')
		modprobe $video $params $flip $invert
	else
		(cd "${BOOTDIR}" && sh modules.custom.sh ) >> "${LOGS}" 2>&1
	fi
fi

# check if it's first boot and defer to the firstboot script if yes
if test -r "${BOOTDIR}/firstboot"; then
	exec sh "${BOOTDIR}/firstboot"
elif test -r "${HOME}/firstboot.completed"; then
	rm "${HOME}/firstboot.completed"
fi

if !(grep -q FAT_CHECK\=\0 "${HOME}/options.cfg"); then
##Check if fat32 is flagged as "dirty", and if so unmount, repair, remount
	if dmesg | grep "mmcblk0p4" > /dev/null;  then
		echo -e "\e[31mUnclean shutdown detected.\e[0m"
		echo -e "\e[32mChecking FAT32 partition...\e[0m"
		umount /dev/mmcblk0p4
		fsck.vfat -y /dev/mmcblk0p4 > /dev/null;
		mount /dev/mmcblk0p4 "${HOME}" -t vfat -o rw,sync,utf8
		echo -e "\e[32mCheck complete.\e[0m"
	fi
fi

clear

# try to read what handheld we're on
if test -r "${BOOTDIR}/console.cfg"; then
	source "${BOOTDIR}/console.cfg"
else
	export CONSOLE_VARIANT="unknown"
fi

echo "Boot!" >> "${LOGS}"
echo "Handheld type is ${CONSOLE_VARIANT}" >> "${LOGS}"

# run any custom commands ('daemon' expected to be run from there)
if test -r "${BOOTDIR}/normalboot.custom.sh" ; then
	(cd "${BOOTDIR}" && sh normalboot.custom.sh) # don't redirect, want output on screen
else
	# at least run 'daemon'
	daemon >> "${LOGS}" 2>&1
fi

# run boot logo animation
if (!(grep -q BOOT_LOGO\=\0 "${HOME}/options.cfg")); then
	${BOOTLOGO} >> "${LOGS}" 2>&1
fi

# can't unmount boot because 'daemon' runs from it - but it's mounted read-only
#  so it's fine
## umount /dev/mmcblk0p1

# Writes dmesg after firstboot procedure or if DEBUG_MSG=yes
if test "x${DEBUG_MSG}" == "xyes"; then
	sleep 1
	dmesg > ${HOME}/dmesg.txt
	mv ${LOGS} ${HOME}/log.txt
fi

#while [ 1 ]
#do
#	if test -f "${START}"; then
#		source "${START}"
#	else
#		cd "${HOME}"/gmenu2x;
#		./gmenu2x >> /dev/null 2>&1;
#	fi
#	clear
#done

#---- Authors: jahed[https://github.com/jahed/powkiddy-v90]

echo -e "\e[?1c" #replace 1 with 3 to see text
#/mnt/kernel/setcolors /mnt/kernel/colors

clear; echo -e "\n\n\n\n\n\n\n\n\n\n\n\n\n\n              \e[1;33m[ STARTING ]\e[0m"

modprobe r61520fb.ko

if test "$(cat /sys/class/power_supply/miyoo-battery/voltage_now)" -lt '3400'; then
  clear; echo -e "\n\n\n\n\n\n\n\n\n\n\n\n\n\n            \e[1;33m[ LOW BATTERY ]\e[0m"
  sync
  sleep 1
  poweroff
  exit
fi

#Check if fat32 is flagged as "dirty", and if so unmount, repair, remount
if dmesg | grep "mmcblk0p4" > /dev/null;  then
  clear; echo -e "\n\n\n\n\n\n\n\n\n\n\n\n\n\n             \e[1;33m[ REPAIRING ]\e[0m"
  umount /dev/mmcblk0p4
  fsck.vfat -y /dev/mmcblk0p4 > /dev/null; 
  mount /dev/mmcblk0p4 /mnt -t vfat -o rw,sync,utf8
fi

/mnt/kernel/daemon > /dev/null 2>&1

function start_retroarch {
  cd /mnt/emus/retroarch
  if ! read -n 1 -t 1 -s; then
    local history_path='/mnt/retroarch/content_history.lpl'
    if test -f "${history_path}"; then
      local rom_path="$(head -n20 "${history_path}" | grep -Eo -m1 '/mnt/roms/[^"]+')"
      local core_path="$(head -n20 "${history_path}" | grep -Eo -m1 '/mnt/retroarch/cores/.+\.so')"
      if test -f "${core_path}" -a -f "${rom_path}"; then
        clear; echo -e "\n\n\n\n\n\n\n\n\n\n\n\n\n\n              \e[1;33m[ LOADING ]\e[0m"
        ./retroarch --config /mnt/retroarch/retroarch.cfg --load-menu-on-error --libretro "${core_path}" "${rom_path}" > /dev/null 2>&1 &
        return
      fi
    fi
  fi
  ./retroarch --config /mnt/retroarch/retroarch.cfg --menu > /dev/null 2>&1 &
}

function check_battery {
  while true; do
    sleep 300
    if test "$(cat /sys/class/power_supply/miyoo-battery/voltage_now)" -lt '3400'; then
      clear; echo -e "\n\n\n\n\n\n\n\n\n\n\n\n\n\n            \e[1;33m[ LOW BATTERY ]\e[0m"
      kill -TERM "${1}"
    fi
  done
}

start_retroarch
retroarch_pid="${!}"

sleep 1
clear; echo -e "\n\n\n\n\n\n\n\n\n\n\n\n\n\n               \e[1;33m[ SAVING ]\e[0m"

check_battery "${retroarch_pid}" &

wait "${retroarch_pid}"
sync
poweroff
